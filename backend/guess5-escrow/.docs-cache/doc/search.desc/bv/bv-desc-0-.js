searchState.loadedDescShard("bv", 0, "The main type exported by the library, <code>BitVec</code>, is a packed,\nA slice of a bit-vector; akin to <code>&amp;&#39;a [bool]</code> but packed.\nA mutable slice of a bit-vector; akin to <code>&amp;&#39;a mut [bool]</code> …\nTypes that support slicing by ranges.\nTypes that produce mutable slices.\nA bit-vector, akin to <code>Vec&lt;bool&gt;</code> but packed.\nRead-only bit vector operations.\nExtension trait for adapter operations on bit slices.\nMutable bit vector operations that don’t affect the …\nExtension trait for mutable operations on bit slices.\nBit vector operations that change the length.\nThe underlying block type used to store the bits of the …\nInterface to primitive bit storage.\nThe type of the slice produced.\nLazy bit vector adapters.\nPushes <code>value</code> 0 or more times until the size of the bit …\nPushes <code>value</code> 0 or more times until the size of the bit …\nConverts a mutable bit slice to immutable.\nGets a mutable slice to a <code>BitVec</code>.\nGets a slice to a <code>BitVec</code>.\nReturns an object that lazily computes the bit-wise …\nReturns an object that lazily computes the bit-wise …\nAssigns the bit-wise <em>and</em> of <code>self</code> and <code>other</code> to <code>self</code>.\nAssigns the bit-wise <em>and</em> of <code>self</code> and <code>other</code> to <code>self</code>.\nAssigns the bits of <code>other</code> to <code>self</code>.\nAssigns the bits of <code>other</code> to <code>self</code>.\nConcatenates two bit vectors, with the bits of <code>self</code> …\nConcatenates two bit vectors, with the bits of <code>self</code> …\nThe length of the slice in bits.\nReturns an object that inverts the values of all the bits …\nReturns an object that inverts the values of all the bits …\nReturns an object that lazily computes the bit-wise …\nReturns an object that lazily computes the bit-wise …\nAssigns the bit-wise <em>or</em> of <code>self</code> and <code>other</code> to <code>self</code>.\nAssigns the bit-wise <em>or</em> of <code>self</code> and <code>other</code> to <code>self</code>.\nPads <code>self</code> with 0s on the right to reach at least <code>len</code> bits …\nPads <code>self</code> with 0s on the right to reach at least <code>len</code> bits …\nSlices or re-slices the given object.\nAn alias for <code>BitSliceable::bit_slice</code>.\nAn alias for <code>BitSliceable::bit_slice</code>.\nLike <code>vec!</code> but for <code>BitVec</code>.\nReturns an object that lazily computes the bit-wise xor of …\nReturns an object that lazily computes the bit-wise xor of …\nAssigns the bit-wise <em>xor</em> of <code>self</code> and <code>other</code> to <code>self</code>.\nAssigns the bit-wise <em>xor</em> of <code>self</code> and <code>other</code> to <code>self</code>.\nReturns an object that lazily zips a function over the …\nReturns an object that lazily zips a function over the …\nPerforms an op-assignment from <code>other</code> to <code>self</code>.\nPerforms an op-assignment from <code>other</code> to <code>self</code>.\nThe number of bits in the block at <code>position</code>, given a total …\nThe number of bits in the block at <code>position</code>, given a total …\nThe capacity of the bit-vector in blocks.\nThe length of the slice in blocks.\nThe length of the slice in blocks.\nThe number of blocks used by this bit-vector.\nAdjust the capacity to hold at least <code>additional</code> additional …\nAdjusts the capacity to at least <code>additional</code> blocks beyond …\nThe capacity of the bit-vector in bits.\nReturns <code>index / Self::nbits()</code> rounded up, computed by …\nReturns <code>index / Self::nbits()</code> rounded up, computed by …\nReturns the smallest number <code>n</code> such that <code>2.pow(n) &gt;= self</code>.\nReturns the smallest number <code>n</code> such that <code>2.pow(n) &gt;= self</code>.\nReturns <code>index / Self::nbits()</code> rounded up, computed by …\nReturns <code>index / Self::nbits()</code> rounded up, computed by …\nReturns <code>index / Self::nbits()</code>, computed by shifting.\nReturns <code>index / Self::nbits()</code>, computed by shifting.\nRemoves all elements from the bit-vector.\nReturns <code>index / Self::nbits()</code>, computed by shifting.\nReturns <code>index / Self::nbits()</code>, computed by shifting.\nReturns the largest number <code>n</code> such that <code>2.pow(n) &lt;= self</code>.\nReturns the largest number <code>n</code> such that <code>2.pow(n) &lt;= self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>BitVec</code> from any value implementing the <code>Bits</code> …\nCreates a <code>BitSliceMut</code> from a pointer to its data, an …\nCreates a <code>BitSlice</code> from a pointer to its data, an offset …\nCreates a <code>BitSliceMut</code> from a mutable array slice of blocks.\nCreates a <code>BitSlice</code> from an array slice of blocks.\nGets the value of the bit at the given position.\nExtracts the value of the <code>bit_index</code>th bit.\nExtracts the value of the <code>bit_index</code>th bit.\nGets the bit at <code>position</code>\nGets the bit at <code>position</code>\nExtracts <code>len</code> bits starting at bit offset <code>start</code>.\nExtracts <code>len</code> bits starting at bit offset <code>start</code>.\nGets <code>count</code> bits starting at bit index <code>start</code>, interpreted …\nGets <code>count</code> bits starting at bit index <code>start</code>, interpreted …\nGets the block at <code>position</code>, masked as necessary.\nGets the block at <code>position</code>, masked as necessary.\nGets the block at <code>position</code>, without masking.\nGets the block at <code>position</code>, without masking.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an object that lazily computes the bit-wise …\nReturns an object that lazily computes the bit-wise …\nConcatenates two bit vectors, with the bits of <code>self</code> …\nConcatenates two bit vectors, with the bits of <code>self</code> …\nReturns an object that inverts the values of all the bits …\nReturns an object that inverts the values of all the bits …\nReturns an object that lazily computes the bit-wise …\nReturns an object that lazily computes the bit-wise …\nPads <code>self</code> with 0s on the right to reach at least <code>len</code> bits …\nPads <code>self</code> with 0s on the right to reach at least <code>len</code> bits …\nReturns an object that lazily computes the bit-wise xor of …\nReturns an object that lazily computes the bit-wise xor of …\nReturns an object that lazily zips a function over the …\nReturns an object that lazily zips a function over the …\nConverts the vector into <code>Box&lt;[Block]&gt;</code>.\nReturns whether there are no bits in the slice.\nReturns whether there are no bits in the slice.\nDoes the bit-vector have no elements?\nReturns the number of leading zero bits in the given …\nThe number of bits in the slice.\nThe number of bits in the slice.\nThe number of bits in the bit-vector.\nLog-base-2 of the number of bits in a block.\nLog-base-2 of the number of bits in a block.\nMask with the lowest-order <code>lg_nbits()</code> set.\nMask with the lowest-order <code>lg_nbits()</code> set.\nThe bit mask consisting of <code>Self::nbits() - element_bits</code> …\nThe bit mask consisting of <code>Self::nbits() - element_bits</code> …\nReturns <code>index % Self::nbits()</code>, computed by masking.\nReturns <code>index % Self::nbits()</code>, computed by masking.\nReturns <code>index * Self::nbits()</code>, computed by shifting.\nReturns <code>index * Self::nbits()</code>, computed by shifting.\nThe number of bits in a block.\nThe number of bits in a block.\nCreates a new, empty bit-vector with a capacity of one …\nCreates a new bit-vector of size <code>len</code>, filled with all 0s …\nThe bit mask with the <code>bit_index</code>th bit set.\nThe bit mask with the <code>bit_index</code>th bit set.\nReturns 1.\nRemoves and returns the last element of the bit-vector, or …\nRemoves and returns the last bit, if any.\nAdds the given <code>bool</code> to the end of the bit-vector.\nAdds the given bit to the end of the bit vector.\nPushes the given block onto the end of the bit vector.\nPushes the given block onto the end of the bit vector.\nAdjust the capacity to hold at least <code>additional</code> additional …\nAdjust the capacity to hold at least <code>additional</code> additional …\nResizes the bit-vector, filling with <code>value</code> if it has to …\nSets the value of the bit at the given position.\nSets the bit at <code>position</code> to <code>value</code>.\nSets the bit at <code>position</code> to <code>value</code>.\nSets <code>count</code> bits starting at bit index <code>start</code>, interpreted …\nSets <code>count</code> bits starting at bit index <code>start</code>, interpreted …\nSets the block at <code>position</code> to <code>value</code>.\nSets the block at <code>position</code> to <code>value</code>.\nShrinks the capacity of the vector as much as possible.\nCopies the bits into a new allocated <code>BitVec</code>.\nCopies the bits into a new allocated <code>BitVec</code>.\nConverts the number to a <code>usize</code>, if it fits.\nShortens the vector, keeping the first <code>len</code> elements and …\nFunctionally updates the value of the <code>bit_index</code>th bit to …\nFunctionally updates the value of the <code>bit_index</code>th bit to …\nFunctionally updates <code>len</code> bits to <code>value</code> starting at offset …\nFunctionally updates <code>len</code> bits to <code>value</code> starting at offset …\nCreates a new, empty bit-vector with the given block …\nCreates a new, empty bit-vector with the given bit …\nA shift-left operation that does not overflow.\nA subtraction operation that does not overflow.\nReturns 0.\nThe result of <code>BitsExt::bit_and</code>.\nThe result of <code>BitsExt::bit_concat</code>.\nEmulates a constant-valued bit-vector of a given size.\nThe result of <code>BitsExt::bit_not</code>.\nThe result of <code>BitsExt::bit_or</code>.\nAn adapter that turns any implementation of <code>Bits</code> into a …\nThe result of <code>BitsExt::bit_xor</code>.\nThe result of <code>BitsExt::bit_zip</code>.\nAdapts a sequence of <code>bool</code>s (<em>e.g.,</em> <code>&amp;[bool]</code>) to emulate a bit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGets the underlying <code>bool</code> sequence object back out of a …\nCreates a new slice adaptor from the given bit-vector-like.\nCreates a new <code>BoolAdapter</code> from an underlying sequence of …\nConstructs a compact bit-vector-like of <code>len</code> 1s.\nConstructs a compact bit-vector-like of <code>len</code> 0s.")