import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import { AppDataSource } from '../db';
import { Match } from '../models/Match';
import { createPremiumSolanaConnection } from '../config/solanaConnection';
import { config } from '../config/environment';
import {
  createSignedResult,
  getBackendSignerPubkey,
} from '../utils/escrowSigning';
// IDL will be generated by Anchor build
// For now, we'll use a dynamic import
// IDL will be loaded at runtime from the types folder (copied to dist/types during build)
const IDL = require('../types/game-escrow.json');

/**
 * Escrow service for managing game escrow accounts
 * Replaces the Squads multisig vault system
 */

// Lazy initialization to prevent errors during module load
let connection: Connection | null = null;
let PROGRAM_ID: PublicKey | null = null;

function getConnection(): Connection {
  if (!connection) {
    try {
      connection = createPremiumSolanaConnection();
    } catch (error) {
      console.error('‚ùå Failed to create Solana connection:', error);
      throw new Error('Failed to initialize Solana connection. Check HELIUS_API_KEY and SOLANA_NETWORK environment variables.');
    }
  }
  return connection;
}

function getProgramId(): PublicKey {
  if (!PROGRAM_ID) {
    try {
      const programIdString = config.smartContract.programId;
      if (!programIdString) {
        throw new Error('SMART_CONTRACT_PROGRAM_ID environment variable is not set');
      }
      PROGRAM_ID = new PublicKey(programIdString);
      console.log('‚úÖ PROGRAM_ID initialized:', PROGRAM_ID.toString());
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('‚ùå Failed to initialize PROGRAM_ID:', errorMessage);
      console.error('‚ùå Config smartContract.programId:', config.smartContract.programId);
      throw new Error(`Failed to initialize PROGRAM_ID: ${errorMessage}. Check SMART_CONTRACT_PROGRAM_ID environment variable.`);
    }
  }
  return PROGRAM_ID;
}

// Create a wallet from the fee wallet private key for Anchor provider
function getProviderWallet(): Wallet {
  const privateKey = process.env.FEE_WALLET_PRIVATE_KEY;
  if (!privateKey) {
    throw new Error('FEE_WALLET_PRIVATE_KEY must be set');
  }

  // Decode private key
  const keypair = Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(privateKey))
  );

  return new Wallet(keypair);
}

function getProgram(): any {
  const wallet = getProviderWallet();
  const conn = getConnection();
  const programId = getProgramId();
  const provider = new AnchorProvider(conn, wallet, {
    commitment: 'confirmed',
  });

  // Fix: Program constructor - cast all arguments to any to avoid type issues
  return new Program(IDL as any, programId as any, provider as any) as any;
}

/**
 * Derive the escrow PDA for a match
 */
export function deriveEscrowPDA(matchId: string): [PublicKey, number] {
  try {
    // Convert UUID to bytes (remove dashes and convert hex to bytes)
    const uuidHex = matchId.replace(/-/g, '');
    
    // Validate UUID format (should be 32 hex chars after removing dashes)
    if (uuidHex.length !== 32) {
      throw new Error(`Invalid matchId format: expected 32 hex characters, got ${uuidHex.length} (matchId: ${matchId})`);
    }
    
    const matchIdBytes = Buffer.from(uuidHex, 'hex');
    
    // Get PROGRAM_ID (will initialize if needed)
    const programId = getProgramId();

    return PublicKey.findProgramAddressSync(
      [Buffer.from('match'), matchIdBytes],
      programId
    );
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error in deriveEscrowPDA:', {
      error: errorMessage,
      matchId,
      programId: PROGRAM_ID?.toString(),
      envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw error;
  }
}

/**
 * Derive escrow address for a match (doesn't initialize on-chain)
 * The escrow will be initialized when Player A signs the initialize transaction
 */
export async function deriveMatchEscrowAddress(
  matchId: string
): Promise<{ success: boolean; escrowAddress?: string; error?: string }> {
  try {
    // Validate matchId
    if (!matchId || typeof matchId !== 'string') {
      throw new Error(`Invalid matchId: ${matchId}`);
    }
    
    // Initialize PROGRAM_ID if needed (will throw if invalid)
    const programId = getProgramId();
    
    console.log('üîç Deriving escrow PDA for match:', {
      matchId,
      programId: programId.toString(),
    });
    
    const [escrowPDA, bump] = deriveEscrowPDA(matchId);

    console.log('‚úÖ Match escrow address derived:', {
      matchId,
      escrowAddress: escrowPDA.toString(),
      bump,
    });

    return {
      success: true,
      escrowAddress: escrowPDA.toString(),
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error('‚ùå Error deriving match escrow address:', {
      error: errorMessage,
      matchId,
      stack: errorStack,
      programId: PROGRAM_ID?.toString(),
      envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
      configProgramId: config.smartContract.programId,
    });
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create initialize transaction for Player A to sign
 * This returns a transaction that Player A must sign to initialize the escrow
 */
export async function createInitializeTransaction(
  matchId: string,
  playerA: string,
  playerB: string,
  entryFee: number
): Promise<{ success: boolean; transaction?: Transaction; escrowAddress?: string; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA, bump] = deriveEscrowPDA(matchId);

    // Convert match ID to u128 (convert UUID hex to BN)
    const uuidHex = matchId.replace(/-/g, '');
    // Take first 16 bytes (32 hex chars) for u128
    const matchIdHex = uuidHex.substring(0, 32);
    const matchIdBN = new BN(matchIdHex, 16);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await (program.methods as any)
      .initializeMatch(matchIdBN, entryFeeLamports)
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(playerA),
        playerB: new PublicKey(playerB),
        systemProgram: SystemProgram.programId,
      })
      .transaction();

    console.log('‚úÖ Initialize transaction created:', {
      matchId,
      escrowAddress: escrowPDA.toString(),
    });

    return {
      success: true,
      transaction: tx,
      escrowAddress: escrowPDA.toString(),
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating initialize transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create a deposit transaction for a player
 * Returns the transaction that the player needs to sign
 */
export async function createDepositTransaction(
  matchId: string,
  playerPubkey: string,
  entryFee: number
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await program.methods
      .deposit()
      .accounts({
        gameEscrow: escrowPDA,
        player: new PublicKey(playerPubkey),
        systemProgram: SystemProgram.programId,
      })
      .transaction();

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating deposit transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Submit a game result (called by player to approve result)
 */
export async function submitResult(
  matchId: string,
  playerPubkey: string,
  winner: string | null,
  resultType: 'Win' | 'DrawFullRefund' | 'DrawPartialRefund'
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Create signed result from backend
    const signedResult = await createSignedResult(matchId, winner, resultType);

    // Convert signature to [u8; 64] format
    const signatureArray = Array.from(signedResult.signature);

    const winnerPubkey = winner ? new PublicKey(winner) : null;
    const backendSigner = getBackendSignerPubkey();

    // Map result type to enum (Anchor IDL format)
    let resultTypeEnum: any;
    switch (resultType) {
      case 'Win':
        resultTypeEnum = { win: {} };
        break;
      case 'DrawFullRefund':
        resultTypeEnum = { drawFullRefund: {} };
        break;
      case 'DrawPartialRefund':
        resultTypeEnum = { drawPartialRefund: {} };
        break;
      default:
        throw new Error(`Invalid result type: ${resultType}`);
    }

    // Get ed25519 program ID
    const ed25519ProgramId = new PublicKey('Ed25519SigVerify111111111111111111111111111');

    const tx = await program.methods
      .submitResult(winnerPubkey, resultTypeEnum, signatureArray)
      .accounts({
        gameEscrow: escrowPDA,
        backendSigner: backendSigner,
        player: new PublicKey(playerPubkey),
        ed25519Program: ed25519ProgramId,
      })
      .transaction();

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating submit result transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Settle a match (can be called by anyone after result is submitted or timeout)
 */
export async function settleMatch(
  matchId: string
): Promise<{ success: boolean; transaction?: Transaction; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Fetch escrow account to get winner
    const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);
    const winner = escrowAccount.winner;

    const feeWallet = new PublicKey(config.solana.feeWalletAddress);

    const tx = await program.methods
      .settle()
      .accounts({
        gameEscrow: escrowPDA,
        winner: winner || SystemProgram.programId, // Fallback if no winner
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        feeWallet: feeWallet,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('‚úÖ Match settled:', {
      matchId,
      transaction: tx,
    });

    // Update match in database
    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'SETTLED',
        payoutTxHash: tx,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error settling match:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Refund if only one player paid (after timeout)
 */
export async function refundSinglePlayer(
  matchId: string
): Promise<{ success: boolean; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const tx = await program.methods
      .refundIfOnlyOnePaid()
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('‚úÖ Single player refunded:', {
      matchId,
      transaction: tx,
    });

    // Update match in database
    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'REFUNDED',
        refundTxHash: tx,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error refunding single player:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Get escrow account state
 */
export async function getEscrowState(
  matchId: string
): Promise<{
  success: boolean;
  state?: any;
  error?: string;
}> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);

    return {
      success: true,
      state: escrowAccount,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

