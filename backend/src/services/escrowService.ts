import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import { AppDataSource } from '../db';
import { Match } from '../models/Match';
import { createPremiumSolanaConnection } from '../config/solanaConnection';
import { config } from '../config/environment';
import {
  createSignedResult,
  getBackendSignerPubkey,
} from '../utils/escrowSigning';
// IDL will be generated by Anchor build
// For now, we'll use a dynamic import
const IDL = require('../types/game-escrow.json');

/**
 * Escrow service for managing game escrow accounts
 * Replaces the Squads multisig vault system
 */

const connection = createPremiumSolanaConnection();
const PROGRAM_ID = new PublicKey(config.smartContract.programId);

// Create a wallet from the fee wallet private key for Anchor provider
function getProviderWallet(): Wallet {
  const privateKey = process.env.FEE_WALLET_PRIVATE_KEY;
  if (!privateKey) {
    throw new Error('FEE_WALLET_PRIVATE_KEY must be set');
  }

  // Decode private key
  const keypair = Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(privateKey))
  );

  return new Wallet(keypair);
}

function getProgram(): any {
  const wallet = getProviderWallet();
  const provider = new AnchorProvider(connection, wallet, {
    commitment: 'confirmed',
  });

  // Fix: Program constructor - cast all arguments to any to avoid type issues
  return new Program(IDL as any, PROGRAM_ID as any, provider as any) as any;
}

/**
 * Derive the escrow PDA for a match
 */
export function deriveEscrowPDA(matchId: string): [PublicKey, number] {
  // Convert UUID to bytes (remove dashes and convert hex to bytes)
  const uuidHex = matchId.replace(/-/g, '');
  const matchIdBytes = Buffer.from(uuidHex, 'hex');

  return PublicKey.findProgramAddressSync(
    [Buffer.from('match'), matchIdBytes],
    PROGRAM_ID
  );
}

/**
 * Initialize a match escrow
 * Called when Player A creates a match
 */
export async function initializeMatchEscrow(
  matchId: string,
  playerA: string,
  playerB: string,
  entryFee: number
): Promise<{ success: boolean; escrowAddress?: string; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA, bump] = deriveEscrowPDA(matchId);

    // Convert match ID to u128 (convert UUID hex to BN)
    const uuidHex = matchId.replace(/-/g, '');
    // Take first 16 bytes (32 hex chars) for u128
    const matchIdHex = uuidHex.substring(0, 32);
    const matchIdBN = new BN(matchIdHex, 16);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await (program.methods as any)
      .initializeMatch(matchIdBN, entryFeeLamports)
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(playerA),
        playerB: new PublicKey(playerB),
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('✅ Match escrow initialized:', {
      matchId,
      escrowAddress: escrowPDA.toString(),
      transaction: tx,
    });

    // Update match in database
    const matchRepository = AppDataSource.getRepository(Match);
    await matchRepository.update(
      { id: matchId },
      {
        escrowAddress: escrowPDA.toString(),
        escrowStatus: 'INITIALIZED',
      }
    );

    return {
      success: true,
      escrowAddress: escrowPDA.toString(),
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('❌ Error initializing match escrow:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create a deposit transaction for a player
 * Returns the transaction that the player needs to sign
 */
export async function createDepositTransaction(
  matchId: string,
  playerPubkey: string,
  entryFee: number
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await program.methods
      .deposit()
      .accounts({
        gameEscrow: escrowPDA,
        player: new PublicKey(playerPubkey),
        systemProgram: SystemProgram.programId,
      })
      .transaction();

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('❌ Error creating deposit transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Submit a game result (called by player to approve result)
 */
export async function submitResult(
  matchId: string,
  playerPubkey: string,
  winner: string | null,
  resultType: 'Win' | 'DrawFullRefund' | 'DrawPartialRefund'
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Create signed result from backend
    const signedResult = await createSignedResult(matchId, winner, resultType);

    // Convert signature to [u8; 64] format
    const signatureArray = Array.from(signedResult.signature);

    const winnerPubkey = winner ? new PublicKey(winner) : null;
    const backendSigner = getBackendSignerPubkey();

    // Map result type to enum (Anchor IDL format)
    let resultTypeEnum: any;
    switch (resultType) {
      case 'Win':
        resultTypeEnum = { win: {} };
        break;
      case 'DrawFullRefund':
        resultTypeEnum = { drawFullRefund: {} };
        break;
      case 'DrawPartialRefund':
        resultTypeEnum = { drawPartialRefund: {} };
        break;
      default:
        throw new Error(`Invalid result type: ${resultType}`);
    }

    // Get ed25519 program ID
    const ed25519ProgramId = new PublicKey('Ed25519SigVerify111111111111111111111111111');

    const tx = await program.methods
      .submitResult(winnerPubkey, resultTypeEnum, signatureArray)
      .accounts({
        gameEscrow: escrowPDA,
        backendSigner: backendSigner,
        player: new PublicKey(playerPubkey),
        ed25519Program: ed25519ProgramId,
      })
      .transaction();

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('❌ Error creating submit result transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Settle a match (can be called by anyone after result is submitted or timeout)
 */
export async function settleMatch(
  matchId: string
): Promise<{ success: boolean; transaction?: Transaction; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Fetch escrow account to get winner
    const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);
    const winner = escrowAccount.winner;

    const feeWallet = new PublicKey(config.solana.feeWalletAddress);

    const tx = await program.methods
      .settle()
      .accounts({
        gameEscrow: escrowPDA,
        winner: winner || SystemProgram.programId, // Fallback if no winner
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        feeWallet: feeWallet,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('✅ Match settled:', {
      matchId,
      transaction: tx,
    });

    // Update match in database
    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'SETTLED',
        payoutTxHash: tx,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('❌ Error settling match:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Refund if only one player paid (after timeout)
 */
export async function refundSinglePlayer(
  matchId: string
): Promise<{ success: boolean; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const tx = await program.methods
      .refundIfOnlyOnePaid()
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('✅ Single player refunded:', {
      matchId,
      transaction: tx,
    });

    // Update match in database
    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'REFUNDED',
        refundTxHash: tx,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('❌ Error refunding single player:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Get escrow account state
 */
export async function getEscrowState(
  matchId: string
): Promise<{
  success: boolean;
  state?: any;
  error?: string;
}> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);

    return {
      success: true,
      state: escrowAccount,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

