import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
  TransactionInstruction,
  SYSVAR_INSTRUCTIONS_PUBKEY,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import { AppDataSource } from '../db';
import { Match } from '../models/Match';
import { createPremiumSolanaConnection } from '../config/solanaConnection';
import { config } from '../config/environment';
import {
  createSignedResult,
  getBackendSignerPubkey,
} from '../utils/escrowSigning';
// IDL will be generated by Anchor build
// For now, we'll use a dynamic import
// IDL will be loaded at runtime from the types folder (copied to dist/types during build)
const IDL = require('../types/game-escrow.json');

/**
 * Escrow service for managing game escrow accounts
 * Replaces the Squads multisig vault system
 */

// Lazy initialization to prevent errors during module load
let connection: Connection | null = null;
let PROGRAM_ID: PublicKey | null = null;

function getConnection(): Connection {
  if (!connection) {
    try {
      connection = createPremiumSolanaConnection();
    } catch (error) {
      console.error('‚ùå Failed to create Solana connection:', error);
      throw new Error('Failed to initialize Solana connection. Check HELIUS_API_KEY and SOLANA_NETWORK environment variables.');
    }
  }
  return connection;
}

function getProgramId(): PublicKey {
  if (!PROGRAM_ID) {
    try {
      const programIdString = config.smartContract.programId;
      if (!programIdString) {
        throw new Error('SMART_CONTRACT_PROGRAM_ID environment variable is not set');
      }
      PROGRAM_ID = new PublicKey(programIdString);
      console.log('‚úÖ PROGRAM_ID initialized:', PROGRAM_ID.toString());
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('‚ùå Failed to initialize PROGRAM_ID:', errorMessage);
      console.error('‚ùå Config smartContract.programId:', config.smartContract.programId);
      throw new Error(`Failed to initialize PROGRAM_ID: ${errorMessage}. Check SMART_CONTRACT_PROGRAM_ID environment variable.`);
    }
  }
  return PROGRAM_ID;
}

// Create a wallet from the fee wallet private key for Anchor provider
function getProviderWallet(): Wallet {
  const privateKey = process.env.FEE_WALLET_PRIVATE_KEY;
  if (!privateKey) {
    throw new Error('FEE_WALLET_PRIVATE_KEY must be set');
  }

  // Decode private key
  const keypair = Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(privateKey))
  );

  return new Wallet(keypair);
}

function getProgram(): any {
  const wallet = getProviderWallet();
  const conn = getConnection();
  const programId = getProgramId();
  const provider = new AnchorProvider(conn, wallet, {
    commitment: 'confirmed',
  });

  // Fix: Program constructor - cast all arguments to any to avoid type issues
  return new Program(IDL as any, programId as any, provider as any) as any;
}

/**
 * Derive the escrow PDA for a match
 */
export function deriveEscrowPDA(matchId: string): [PublicKey, number] {
  try {
    // Convert UUID to bytes (remove dashes and convert hex to bytes)
    const uuidHex = matchId.replace(/-/g, '');
    
    // Validate UUID format (should be 32 hex chars after removing dashes)
    if (uuidHex.length !== 32) {
      throw new Error(`Invalid matchId format: expected 32 hex characters, got ${uuidHex.length} (matchId: ${matchId})`);
    }
    
    const matchIdBytes = Buffer.from(uuidHex, 'hex');
    
    // Get PROGRAM_ID (will initialize if needed)
    const programId = getProgramId();

    return PublicKey.findProgramAddressSync(
      [Buffer.from('match'), matchIdBytes],
      programId
    );
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error in deriveEscrowPDA:', {
      error: errorMessage,
      matchId,
      programId: PROGRAM_ID?.toString(),
      envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw error;
  }
}

/**
 * Derive escrow address for a match (doesn't initialize on-chain)
 * The escrow will be initialized when Player A signs the initialize transaction
 */
export async function deriveMatchEscrowAddress(
  matchId: string
): Promise<{ success: boolean; escrowAddress?: string; error?: string }> {
  try {
    // Validate matchId
    if (!matchId || typeof matchId !== 'string') {
      throw new Error(`Invalid matchId: ${matchId}`);
    }
    
    // Initialize PROGRAM_ID if needed (will throw if invalid)
    let programId: PublicKey;
    try {
      programId = getProgramId();
      console.log('üîç Deriving escrow PDA for match:', {
        matchId,
        programId: programId.toString(),
        envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
        configProgramId: config.smartContract.programId,
      });
    } catch (programIdError: unknown) {
      const errorMsg = programIdError instanceof Error ? programIdError.message : String(programIdError);
      console.error('‚ùå Failed to get PROGRAM_ID:', {
        error: errorMsg,
        envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
        configProgramId: config.smartContract.programId,
      });
      throw new Error(`PROGRAM_ID initialization failed: ${errorMsg}. Check SMART_CONTRACT_PROGRAM_ID environment variable.`);
    }
    
    const [escrowPDA, bump] = deriveEscrowPDA(matchId);

    console.log('‚úÖ Match escrow address derived:', {
      matchId,
      escrowAddress: escrowPDA.toString(),
      bump,
    });

    return {
      success: true,
      escrowAddress: escrowPDA.toString(),
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error('‚ùå Error deriving match escrow address:', {
      error: errorMessage,
      matchId,
      stack: errorStack,
      programId: PROGRAM_ID?.toString(),
      envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
      configProgramId: config.smartContract.programId,
    });
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create initialize transaction for Player A to sign
 * This returns a transaction that Player A must sign to initialize the escrow
 */
export async function createInitializeTransaction(
  matchId: string,
  playerA: string,
  playerB: string,
  entryFee: number
): Promise<{ success: boolean; transaction?: Transaction; escrowAddress?: string; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA, bump] = deriveEscrowPDA(matchId);

    // Convert match ID to u128 (convert UUID hex to BN)
    const uuidHex = matchId.replace(/-/g, '');
    // Take first 16 bytes (32 hex chars) for u128
    const matchIdHex = uuidHex.substring(0, 32);
    const matchIdBN = new BN(matchIdHex, 16);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await (program.methods as any)
      .initializeMatch(matchIdBN, entryFeeLamports)
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(playerA),
        playerB: new PublicKey(playerB),
        systemProgram: SystemProgram.programId,
      })
      .transaction();

    console.log('‚úÖ Initialize transaction created:', {
      matchId,
      escrowAddress: escrowPDA.toString(),
    });

    return {
      success: true,
      transaction: tx,
      escrowAddress: escrowPDA.toString(),
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating initialize transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create a deposit transaction for a player
 * Returns the transaction that the player needs to sign
 */
export async function createDepositTransaction(
  matchId: string,
  playerPubkey: string,
  entryFee: number
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await program.methods
      .deposit()
      .accounts({
        gameEscrow: escrowPDA,
        player: new PublicKey(playerPubkey),
        systemProgram: SystemProgram.programId,
      })
      .transaction();

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating deposit transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create Ed25519 signature instruction for transaction
 * This instruction must be added BEFORE the submit_result instruction
 * Format: [num_signatures(1), sig_offset(2), sig_ix_idx(1), pubkey_offset(2), pubkey_ix_idx(1),
 *          msg_offset(2), msg_len(2), msg_ix_idx(1), signature(64), pubkey(32), message(...)]
 * All instruction indices reference index 0 (this instruction itself)
 */
function createEd25519SignatureInstruction(
  publicKey: PublicKey,
  signature: Uint8Array,
  message: Uint8Array
): TransactionInstruction {
  const ed25519ProgramId = new PublicKey('Ed25519SigVerify111111111111111111111111111');
  
  const numSignatures = 1;
  const sigOffset = 9; // After header (9 bytes)
  const pubkeyOffset = sigOffset + 64; // After signature
  const msgOffset = pubkeyOffset + 32; // After pubkey
  const msgLen = message.length;
  const instructionIndex = 0; // This instruction is at index 0
  
  const instructionData = Buffer.alloc(9 + 64 + 32 + message.length);
  let offset = 0;
  
  // Header (9 bytes)
  instructionData.writeUInt8(numSignatures, offset++); // num_signatures
  instructionData.writeUInt16LE(sigOffset, offset); offset += 2; // sig_offset
  instructionData.writeUInt8(instructionIndex, offset++); // sig_ix_idx
  instructionData.writeUInt16LE(pubkeyOffset, offset); offset += 2; // pubkey_offset
  instructionData.writeUInt8(instructionIndex, offset++); // pubkey_ix_idx
  instructionData.writeUInt16LE(msgOffset, offset); offset += 2; // msg_offset
  instructionData.writeUInt16LE(msgLen, offset); offset += 2; // msg_len
  instructionData.writeUInt8(instructionIndex, offset++); // msg_ix_idx
  
  // Data (signature, pubkey, message)
  Buffer.from(signature).copy(instructionData, offset); offset += 64;
  publicKey.toBytes().copy(instructionData, offset); offset += 32;
  Buffer.from(message).copy(instructionData, offset);
  
  return new TransactionInstruction({
    programId: ed25519ProgramId,
    keys: [], // Ed25519 program doesn't use accounts
    data: instructionData,
  });
}

/**
 * Submit a game result (backend can submit directly, or players can submit)
 */
export async function submitResult(
  matchId: string,
  playerPubkey: string | null, // Optional - backend can submit directly
  winner: string | null,
  resultType: 'Win' | 'DrawFullRefund' | 'DrawPartialRefund'
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Create signed result from backend
    const signedResult = await createSignedResult(matchId, winner, resultType);

    // Convert signature to [u8; 64] format
    const signatureArray = Array.from(signedResult.signature);

    const winnerPubkey = winner ? new PublicKey(winner) : null;
    const backendSigner = getBackendSignerPubkey();

    // Map result type to enum (Anchor IDL format)
    let resultTypeEnum: any;
    switch (resultType) {
      case 'Win':
        resultTypeEnum = { win: {} };
        break;
      case 'DrawFullRefund':
        resultTypeEnum = { drawFullRefund: {} };
        break;
      case 'DrawPartialRefund':
        resultTypeEnum = { drawPartialRefund: {} };
        break;
      default:
        throw new Error(`Invalid result type: ${resultType}`);
    }

    // Get the message bytes that were signed (for ed25519 instruction)
    // This must match what was signed in createSignedResult
    const matchIdBigInt = BigInt(matchId);
    const resultTypeEnumValue = {
      'Win': 1,
      'DrawFullRefund': 2,
      'DrawPartialRefund': 3,
    }[resultType] || 0;
    
    // Manually serialize to match Rust Borsh format exactly (same as escrowSigning.ts)
    const buf = Buffer.alloc(16 + 1 + (winner ? 32 : 0) + 1);
    let offset = 0;
    
    // Serialize match_id as u128 (little-endian, 16 bytes)
    const matchIdBytes = Buffer.alloc(16);
    matchIdBytes.writeBigUInt64LE(matchIdBigInt & BigInt('0xFFFFFFFFFFFFFFFF'), 0);
    matchIdBytes.writeBigUInt64LE(matchIdBigInt >> BigInt(64), 8);
    matchIdBytes.copy(buf, offset);
    offset += 16;
    
    // Serialize Option<Pubkey>
    if (winner) {
      buf.writeUInt8(1, offset++);
      new PublicKey(winner).toBytes().copy(buf, offset);
      offset += 32;
    } else {
      buf.writeUInt8(0, offset++);
    }
    
    // Serialize result_type as u8
    buf.writeUInt8(resultTypeEnumValue, offset);
    
    const messageBytes = buf;

    // Create ed25519 signature instruction (must be FIRST in transaction)
    const ed25519Ix = createEd25519SignatureInstruction(
      backendSigner,
      signedResult.signature,
      messageBytes
    );

    // Determine who submits (backend or player)
    const submitterPubkey = playerPubkey ? new PublicKey(playerPubkey) : backendSigner;

    // Create submit_result instruction
    const submitIx = await program.methods
      .submitResult(winnerPubkey, resultTypeEnum, signatureArray)
      .accounts({
        gameEscrow: escrowPDA,
        backendSigner: backendSigner,
        player: submitterPubkey, // Can be backend or player
        instructionsSysvar: SYSVAR_INSTRUCTIONS_PUBKEY,
      })
      .instruction();

    // Build transaction with ed25519 instruction FIRST, then submit_result
    const tx = new Transaction();
    tx.add(ed25519Ix); // Must be first
    tx.add(submitIx);  // Then submit_result

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating submit result transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Settle a match (can be called by anyone after result is submitted or timeout)
 */
export async function settleMatch(
  matchId: string
): Promise<{ success: boolean; transaction?: Transaction; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Fetch escrow account to get winner
    const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);
    const winner = escrowAccount.winner;

    const feeWallet = new PublicKey(config.solana.feeWalletAddress);

    const tx = await program.methods
      .settle()
      .accounts({
        gameEscrow: escrowPDA,
        winner: winner || SystemProgram.programId, // Fallback if no winner
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        feeWallet: feeWallet,
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('‚úÖ Match settled:', {
      matchId,
      transaction: tx,
    });

    // Update match in database
    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'SETTLED',
        payoutTxHash: tx,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error settling match:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Refund if only one player paid (after timeout)
 */
export async function refundSinglePlayer(
  matchId: string
): Promise<{ success: boolean; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const tx = await program.methods
      .refundIfOnlyOnePaid()
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('‚úÖ Single player refunded:', {
      matchId,
      transaction: tx,
    });

    // Update match in database
    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'REFUNDED',
        refundTxHash: tx,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error refunding single player:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Get escrow account state
 */
export async function getEscrowState(
  matchId: string
): Promise<{
  success: boolean;
  state?: any;
  error?: string;
}> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);

    return {
      success: true,
      state: escrowAccount,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

