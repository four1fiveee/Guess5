import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
  Keypair,
  LAMPORTS_PER_SOL,
  TransactionInstruction,
  SYSVAR_INSTRUCTIONS_PUBKEY,
} from '@solana/web3.js';
import { Program, AnchorProvider, Wallet, BN } from '@coral-xyz/anchor';
import { AppDataSource } from '../db';
import { Match } from '../models/Match';
import { createPremiumSolanaConnection } from '../config/solanaConnection';
import { config } from '../config/environment';
import {
  buildMatchResultMessage,
  createSignedResult,
  getBackendSignerPubkey,
} from '../utils/escrowSigning';
// IDL will be generated by Anchor build
// For now, we'll use a dynamic import
// IDL will be loaded at runtime from the types folder (copied to dist/types during build)
const IDL = require('../types/game-escrow.json');

/**
 * Escrow service for managing game escrow accounts
 * Replaces the Squads multisig vault system
 */

// Lazy initialization to prevent errors during module load
let connection: Connection | null = null;
let PROGRAM_ID: PublicKey | null = null;

function getConnection(): Connection {
  if (!connection) {
    try {
      connection = createPremiumSolanaConnection();
    } catch (error) {
      console.error('‚ùå Failed to create Solana connection:', error);
      throw new Error('Failed to initialize Solana connection. Check HELIUS_API_KEY and SOLANA_NETWORK environment variables.');
    }
  }
  return connection;
}

function getProgramId(): PublicKey {
  if (!PROGRAM_ID) {
    try {
      const programIdString = config.smartContract.programId;
      if (!programIdString) {
        throw new Error('SMART_CONTRACT_PROGRAM_ID environment variable is not set');
      }
      PROGRAM_ID = new PublicKey(programIdString);
      console.log('‚úÖ PROGRAM_ID initialized:', PROGRAM_ID.toString());
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('‚ùå Failed to initialize PROGRAM_ID:', errorMessage);
      console.error('‚ùå Config smartContract.programId:', config.smartContract.programId);
      throw new Error(`Failed to initialize PROGRAM_ID: ${errorMessage}. Check SMART_CONTRACT_PROGRAM_ID environment variable.`);
    }
  }
  return PROGRAM_ID;
}

// Create a wallet from the fee wallet private key for Anchor provider
function getProviderWallet(): Wallet {
  const privateKey = process.env.FEE_WALLET_PRIVATE_KEY;
  if (!privateKey) {
    throw new Error('FEE_WALLET_PRIVATE_KEY must be set');
  }

  // Decode private key - handle potential prefix/suffix issues
  try {
    // Trim any whitespace and check if it's already an array-like string
    const trimmedKey = privateKey.trim();
    
    // Try to parse as JSON array
    const parsedKey = JSON.parse(trimmedKey);
    
    // Ensure it's an array
    if (!Array.isArray(parsedKey)) {
      throw new Error('FEE_WALLET_PRIVATE_KEY must be a JSON array');
    }
    
    const keypair = Keypair.fromSecretKey(
      new Uint8Array(parsedKey)
    );

    return new Wallet(keypair);
  } catch (parseError: unknown) {
    const errorMsg = parseError instanceof Error ? parseError.message : String(parseError);
    console.error('‚ùå Failed to parse FEE_WALLET_PRIVATE_KEY:', {
      error: errorMsg,
      privateKeyPreview: privateKey.substring(0, 20) + '...',
      privateKeyLength: privateKey.length,
    });
    throw new Error(`Failed to parse FEE_WALLET_PRIVATE_KEY: ${errorMsg}`);
  }
}

function getProgram(): any {
  const wallet = getProviderWallet();
  const conn = getConnection();
  const programId = getProgramId();
  const provider = new AnchorProvider(conn, wallet, {
    commitment: 'confirmed',
  });

  // Fix: Program constructor - cast all arguments to any to avoid type issues
  return new Program(IDL as any, programId as any, provider as any) as any;
}

/**
 * Derive the escrow PDA for a match
 */
export function deriveEscrowPDA(matchId: string): [PublicKey, number] {
  try {
    // Convert UUID to bytes matching Rust's u128.to_le_bytes() format
    // Rust does: match_id.to_le_bytes() where match_id is u128
    // In TypeScript, we need to: UUID hex -> BN -> little-endian bytes (16 bytes)
    const uuidHex = matchId.replace(/-/g, '');
    
    // Validate UUID format (should be 32 hex chars after removing dashes)
    if (uuidHex.length !== 32) {
      throw new Error(`Invalid matchId format: expected 32 hex characters, got ${uuidHex.length} (matchId: ${matchId})`);
    }
    
    // Take first 32 hex chars (16 bytes) and convert to BN, then to little-endian bytes
    // This matches Rust: match_id.to_le_bytes() where match_id is u128
    const matchIdHex = uuidHex.substring(0, 32);
    const matchIdBN = new BN(matchIdHex, 16);
    const matchIdBytes = matchIdBN.toArrayLike(Buffer, 'le', 16);
    
    // Get PROGRAM_ID (will initialize if needed)
    const programId = getProgramId();

    return PublicKey.findProgramAddressSync(
      [Buffer.from('match'), matchIdBytes],
      programId
    );
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error in deriveEscrowPDA:', {
      error: errorMessage,
      matchId,
      programId: PROGRAM_ID?.toString(),
      envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
      stack: error instanceof Error ? error.stack : undefined,
    });
    throw error;
  }
}

/**
 * Derive escrow address for a match (doesn't initialize on-chain)
 * The escrow will be initialized when Player A signs the initialize transaction
 */
export async function deriveMatchEscrowAddress(
  matchId: string
): Promise<{ success: boolean; escrowAddress?: string; error?: string }> {
  try {
    // Validate matchId
    if (!matchId || typeof matchId !== 'string') {
      throw new Error(`Invalid matchId: ${matchId}`);
    }
    
    // Initialize PROGRAM_ID if needed (will throw if invalid)
    let programId: PublicKey;
    try {
      programId = getProgramId();
      console.log('üîç Deriving escrow PDA for match:', {
        matchId,
        programId: programId.toString(),
        envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
        configProgramId: config.smartContract.programId,
      });
    } catch (programIdError: unknown) {
      const errorMsg = programIdError instanceof Error ? programIdError.message : String(programIdError);
      console.error('‚ùå Failed to get PROGRAM_ID:', {
        error: errorMsg,
        envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
        configProgramId: config.smartContract.programId,
      });
      throw new Error(`PROGRAM_ID initialization failed: ${errorMsg}. Check SMART_CONTRACT_PROGRAM_ID environment variable.`);
    }
    
    const [escrowPDA, bump] = deriveEscrowPDA(matchId);

    console.log('‚úÖ Match escrow address derived:', {
      matchId,
      escrowAddress: escrowPDA.toString(),
      bump,
    });

    return {
      success: true,
      escrowAddress: escrowPDA.toString(),
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : undefined;
    console.error('‚ùå Error deriving match escrow address:', {
      error: errorMessage,
      matchId,
      stack: errorStack,
      programId: PROGRAM_ID?.toString(),
      envProgramId: process.env.SMART_CONTRACT_PROGRAM_ID,
      configProgramId: config.smartContract.programId,
    });
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create initialize transaction for Player A to sign
 * This returns a transaction that Player A must sign to initialize the escrow
 */
export async function createInitializeTransaction(
  matchId: string,
  playerA: string,
  playerB: string,
  entryFee: number
): Promise<{ success: boolean; transaction?: Transaction; escrowAddress?: string; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA, bump] = deriveEscrowPDA(matchId);

    // Convert match ID to u128 (convert UUID hex to BN)
    const uuidHex = matchId.replace(/-/g, '');
    // Take first 16 bytes (32 hex chars) for u128
    const matchIdHex = uuidHex.substring(0, 32);
    const matchIdBN = new BN(matchIdHex, 16);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await (program.methods as any)
      .initializeMatch(matchIdBN, entryFeeLamports)
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(playerA),
        playerB: new PublicKey(playerB),
        systemProgram: SystemProgram.programId,
      })
      .transaction();

    console.log('‚úÖ Initialize transaction created:', {
      matchId,
      escrowAddress: escrowPDA.toString(),
    });

    return {
      success: true,
      transaction: tx,
      escrowAddress: escrowPDA.toString(),
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating initialize transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create a deposit transaction for a player
 * Returns the transaction that the player needs to sign
 */
export async function createDepositTransaction(
  matchId: string,
  playerPubkey: string,
  entryFee: number
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);
    const entryFeeLamports = new BN(entryFee * LAMPORTS_PER_SOL);

    const tx = await program.methods
      .deposit()
      .accounts({
        gameEscrow: escrowPDA,
        player: new PublicKey(playerPubkey),
        systemProgram: SystemProgram.programId,
      })
      .transaction();

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating deposit transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Create Ed25519 signature instruction for transaction
 * This instruction must be added BEFORE the submit_result instruction
 * Format: [num_signatures(1), sig_offset(2), sig_ix_idx(1), pubkey_offset(2), pubkey_ix_idx(1),
 *          msg_offset(2), msg_len(2), msg_ix_idx(1), signature(64), pubkey(32), message(...)]
 * All instruction indices reference index 0 (this instruction itself)
 */
function createEd25519SignatureInstruction(
  publicKey: PublicKey,
  signature: Uint8Array,
  message: Uint8Array
): TransactionInstruction {
  const ed25519ProgramId = new PublicKey('Ed25519SigVerify111111111111111111111111111');
  
  const numSignatures = 1;
  const sigOffset = 9; // After header (9 bytes)
  const pubkeyOffset = sigOffset + 64; // After signature
  const msgOffset = pubkeyOffset + 32; // After pubkey
  const msgLen = message.length;
  const instructionIndex = 0; // This instruction is at index 0
  
  const instructionData = Buffer.alloc(9 + 64 + 32 + message.length);
  let offset = 0;
  
  // Header (9 bytes)
  instructionData.writeUInt8(numSignatures, offset++); // num_signatures
  instructionData.writeUInt16LE(sigOffset, offset); offset += 2; // sig_offset
  instructionData.writeUInt8(instructionIndex, offset++); // sig_ix_idx
  instructionData.writeUInt16LE(pubkeyOffset, offset); offset += 2; // pubkey_offset
  instructionData.writeUInt8(instructionIndex, offset++); // pubkey_ix_idx
  instructionData.writeUInt16LE(msgOffset, offset); offset += 2; // msg_offset
  instructionData.writeUInt16LE(msgLen, offset); offset += 2; // msg_len
  instructionData.writeUInt8(instructionIndex, offset++); // msg_ix_idx
  
  // Data (signature, pubkey, message)
  Buffer.from(signature).copy(instructionData, offset); offset += 64;
  Buffer.from(publicKey.toBytes()).copy(instructionData, offset); offset += 32;
  Buffer.from(message).copy(instructionData, offset);
  
  return new TransactionInstruction({
    programId: ed25519ProgramId,
    keys: [], // Ed25519 program doesn't use accounts
    data: instructionData,
  });
}

/**
 * Submit a game result (backend can submit directly, or players can submit)
 */
export async function submitResult(
  matchId: string,
  playerPubkey: string | null, // Optional - backend can submit directly
  winner: string | null,
  resultType: 'Win' | 'DrawFullRefund' | 'DrawPartialRefund'
): Promise<{ success: boolean; transaction?: Transaction; error?: string }> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Create signed result from backend
  const signedResult = await createSignedResult(matchId, winner, resultType);

  // Convert signature to [u8; 64] format
  const signatureArray = Array.from(signedResult.signature);

    const backendSigner = getBackendSignerPubkey();

  // Get the message bytes that were signed (for ed25519 instruction).
  // This must match what was signed in createSignedResult.
  const messageBytes = buildMatchResultMessage(signedResult.payload);

    // Create ed25519 signature instruction (must be FIRST in transaction)
    const ed25519Ix = createEd25519SignatureInstruction(
      backendSigner,
      signedResult.signature,
      messageBytes
    );

  // Determine who submits (backend or player)
  const submitterPubkey = playerPubkey
    ? new PublicKey(playerPubkey)
    : backendSigner;

  // Build MatchResult struct argument expected by the Anchor program
  // NOTE: Field names must match the IDL (camelCase representation).
  const uuidHex = matchId.replace(/-/g, '');
  const matchIdHex = uuidHex.substring(0, 32);
  const matchIdBN = new BN(matchIdHex, 16);
  const winnerBytes = winner
    ? new PublicKey(winner).toBytes()
    : new Uint8Array(32); // [0; 32] for draw
  const resultTypeByte =
    {
      Win: 1,
      DrawFullRefund: 2,
      DrawPartialRefund: 3,
    }[resultType] || 0;

  const matchResultArg: any = {
    matchId: matchIdBN,
    winnerPubkey: Array.from(winnerBytes),
    resultType: resultTypeByte,
  };

  // Create submit_result instruction
  const submitIx = await program.methods
    .submitResult(matchResultArg, signatureArray)
      .accounts({
        gameEscrow: escrowPDA,
        backendSigner: backendSigner,
        player: submitterPubkey, // Can be backend or player
        instructionsSysvar: SYSVAR_INSTRUCTIONS_PUBKEY,
      })
      .instruction();

    // Build transaction with ed25519 instruction FIRST, then submit_result
    const tx = new Transaction();
    tx.add(ed25519Ix); // Must be first
    tx.add(submitIx);  // Then submit_result

    return {
      success: true,
      transaction: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error creating submit result transaction:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Submit result and settle match atomically (backend executes both)
 * CRITICAL: submit_result MUST be called before settle can read the winner from escrow account
 * 
 * Flow:
 * 1. Create and send submit_result transaction
 * 2. Wait for confirmation (with retry logic)
 * 3. Validate escrow account state was updated correctly
 * 4. Call settleMatch (which reads winner from escrow account)
 * 5. Return both transaction signatures for database storage
 */
export async function submitResultAndSettle(
  matchId: string,
  winner: string | null,
  resultType: 'Win' | 'DrawFullRefund' | 'DrawPartialRefund'
): Promise<{ 
  success: boolean; 
  submitResultSignature?: string;
  settleSignature?: string;
  signature?: string; // Legacy field for backward compatibility (settle signature)
  error?: string;
}> {
  const [escrowPDA] = deriveEscrowPDA(matchId);
  let submitSignature: string | undefined;
  
  try {
    console.log('üîß [submitResultAndSettle] Initializing program, connection, and repository...', { matchId });
    const program = getProgram();
    const connection = program.provider.connection;
    const matchRepository = AppDataSource.getRepository(Match);
    console.log('‚úÖ [submitResultAndSettle] Initialization complete', { matchId });

    // STEP 1: Submit result on-chain first
    console.log('üìù Step 1: Submitting result to escrow account...', { 
      matchId, 
      winner, 
      resultType,
      escrowPDA: escrowPDA.toString(),
    });
    
    const submitResultTx = await submitResult(matchId, null, winner, resultType);
    
    if (!submitResultTx.success || !submitResultTx.transaction) {
      return {
        success: false,
        error: `Failed to create submit_result transaction: ${submitResultTx.error}`,
      };
    }

    // Send submit_result transaction (backend signs and sends)
    const wallet = getProviderWallet();
    const latestBlockhash = await connection.getLatestBlockhash();
    submitResultTx.transaction.recentBlockhash = latestBlockhash.blockhash;
    submitResultTx.transaction.feePayer = wallet.publicKey;
    
    // Sign with wallet keypair - Wallet.payer is the Keypair
    // Extract it safely with fallback error handling
    const keypair = (wallet as any).payer;
    if (!keypair || typeof keypair.sign !== 'function') {
      const walletKeys = wallet ? Object.keys(wallet) : [];
      throw new Error(`Failed to extract valid keypair from wallet. Wallet keys: ${walletKeys.join(', ')}`);
    }
    submitResultTx.transaction.sign(keypair);
    
    submitSignature = await connection.sendRawTransaction(
      submitResultTx.transaction.serialize(),
      { skipPreflight: false, maxRetries: 3 }
    );
    
    console.log('‚úÖ Submit result transaction sent:', { matchId, signature: submitSignature });
    
    // STEP 2: Wait for confirmation with retry logic (production-grade)
    console.log('‚è≥ Waiting for submit_result confirmation...', { matchId, signature: submitSignature });
    
    const maxRetries = 3;
    let confirmed = false;
    let lastError: Error | null = null;
    
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        await connection.confirmTransaction(submitSignature, 'confirmed');
        confirmed = true;
        console.log('‚úÖ Submit result confirmed:', { matchId, signature: submitSignature, attempt: attempt + 1 });
        break;
      } catch (confirmError: unknown) {
        lastError = confirmError instanceof Error ? confirmError : new Error(String(confirmError));
        if (attempt < maxRetries - 1) {
          const delay = 1000 * (attempt + 1); // Exponential backoff: 1s, 2s, 3s
          console.warn(`‚ö†Ô∏è Confirmation attempt ${attempt + 1} failed, retrying in ${delay}ms...`, {
            matchId,
            signature: submitSignature,
            error: lastError.message,
          });
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    if (!confirmed) {
      return {
        success: false,
        submitResultSignature: submitSignature,
        error: `Failed to confirm submit_result transaction after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`,
      };
    }

    // STEP 3: Validate escrow account state was updated correctly (production-grade validation)
    console.log('üîç Step 3: Validating escrow account state...', { matchId });
    
    try {
      const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);
      
      // Validate winner was set correctly
      if (winner && resultType === 'Win') {
        const expectedWinnerBytes = new PublicKey(winner).toBytes();
        const actualWinnerBytes = escrowAccount.winner;
        
        if (!actualWinnerBytes || !arraysEqual(Array.from(expectedWinnerBytes), Array.from(actualWinnerBytes))) {
          return {
            success: false,
            submitResultSignature: submitSignature,
            error: `Escrow account winner mismatch. Expected: ${winner}, Got: ${escrowAccount.winner ? new PublicKey(escrowAccount.winner).toString() : 'null'}`,
          };
        }
        console.log('‚úÖ Escrow account winner validated:', { 
          matchId, 
          winner: new PublicKey(escrowAccount.winner).toString() 
        });
      } else if (resultType === 'DrawFullRefund' || resultType === 'DrawPartialRefund') {
        // For ties, winner should be null/zero
        const winnerBytes = escrowAccount.winner || new Uint8Array(32);
        const isZero = Array.from(winnerBytes).every(b => b === 0);
        if (!isZero) {
          console.warn('‚ö†Ô∏è Draw result but escrow winner is non-zero:', { 
            matchId,
            winner: escrowAccount.winner ? new PublicKey(escrowAccount.winner).toString() : 'null'
          });
        }
      }
      
      // Store submit_result signature in database (use raw SQL in case column doesn't exist yet)
      try {
        await matchRepository.query(`
          UPDATE "match"
          SET 
            "escrowResultSubmittedAt" = $1,
            "escrowResultSubmittedBy" = $2
          WHERE id = $3
        `, [new Date(), wallet.publicKey.toString(), matchId]);
        
        // Try to update escrowResultSignature if column exists (non-critical)
        try {
          await matchRepository.query(`
            UPDATE "match"
            SET "escrowResultSignature" = $1
            WHERE id = $2
          `, [submitSignature, matchId]);
        } catch (columnError: any) {
          // Column might not exist yet - log but don't fail
          console.warn('‚ö†Ô∏è escrowResultSignature column not found (non-critical):', {
            matchId,
            error: columnError?.message,
          });
        }
      } catch (dbError: any) {
        console.warn('‚ö†Ô∏è Failed to store submit_result metadata (non-critical):', {
          matchId,
          error: dbError?.message,
        });
      }
      
    } catch (validationError: unknown) {
      const errorMsg = validationError instanceof Error ? validationError.message : String(validationError);
      console.error('‚ùå Failed to validate escrow account after submit_result:', {
        matchId,
        submitSignature,
        error: errorMsg,
      });
      // Continue anyway - the transaction was confirmed, so state should be correct
      // But log this for monitoring
    }

    // STEP 4: Now settle (winner is now in escrow account)
    console.log('üí∞ Step 4: Settling match...', { matchId });
    const settleResult = await settleMatch(matchId);
    
    if (!settleResult.success) {
      return {
        success: false,
        submitResultSignature: submitSignature,
        error: `Submit succeeded but settle failed: ${settleResult.error}. Submit signature: ${submitSignature}`,
      };
    }

    // STEP 5: Store both transaction signatures in database
    console.log('üíæ Step 5: Storing transaction signatures...', { 
      matchId, 
      submitSignature, 
      settleSignature: settleResult.signature 
    });
    
    try {
      const freshMatch = await matchRepository.findOne({ where: { id: matchId } });
      let updatedPayoutResult = null;
      if (freshMatch?.payoutResult) {
        try {
          // Handle both string and already-parsed JSON
          updatedPayoutResult = typeof freshMatch.payoutResult === 'string' 
            ? JSON.parse(freshMatch.payoutResult)
            : freshMatch.payoutResult;
        } catch (parseError: unknown) {
          console.warn('‚ö†Ô∏è Failed to parse payoutResult (non-critical):', {
            matchId,
            error: parseError instanceof Error ? parseError.message : String(parseError),
            payoutResultPreview: typeof freshMatch.payoutResult === 'string' 
              ? freshMatch.payoutResult.substring(0, 50) 
              : 'not a string',
          });
          // Continue with null - we'll just not update the payoutResult field
          updatedPayoutResult = null;
        }
      }

      // Add submit_result transaction info to payoutResult
      if (updatedPayoutResult && Array.isArray(updatedPayoutResult.transactions)) {
        // Find and update transactions to include submit_result signature
        updatedPayoutResult.submitResultSignature = submitSignature;
        updatedPayoutResult.submitResultConfirmedAt = new Date().toISOString();
      }

      // Update database with both signatures (use raw SQL for escrowResultSignature in case column doesn't exist)
      await matchRepository.update(
        { id: matchId },
        {
          payoutTxSignature: settleResult.signature, // This is already set by settleMatch, but ensure it's there
          payoutResult: updatedPayoutResult ? JSON.stringify(updatedPayoutResult) : freshMatch?.payoutResult ?? null,
        }
      );
      
      // Try to update escrowResultSignature if column exists (non-critical)
      try {
        await matchRepository.query(`
          UPDATE "match"
          SET "escrowResultSignature" = $1
          WHERE id = $2
        `, [submitSignature, matchId]);
      } catch (columnError: any) {
        // Column might not exist yet - log but don't fail
        console.warn('‚ö†Ô∏è escrowResultSignature column not found (non-critical):', {
          matchId,
          error: columnError?.message,
        });
      }
    } catch (dbError: unknown) {
      console.error('‚ö†Ô∏è Failed to store transaction signatures in database (non-critical):', {
        matchId,
        error: dbError instanceof Error ? dbError.message : String(dbError),
      });
      // Non-critical - transactions succeeded on-chain, DB update can be retried
    }

    console.log('‚úÖ Submit result and settle completed successfully:', {
      matchId,
      submitResultSignature: submitSignature,
      settleSignature: settleResult.signature,
    });

    return {
      success: true,
      submitResultSignature: submitSignature,
      settleSignature: settleResult.signature,
      signature: settleResult.signature, // Legacy field for backward compatibility
    };
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error in submitResultAndSettle:', {
      matchId,
      submitResultSignature: submitSignature,
      error: errorMessage,
      stack: error instanceof Error ? error.stack : undefined,
    });
    return {
      success: false,
      submitResultSignature: submitSignature,
      error: errorMessage,
    };
  }
}

/**
 * Helper function to compare byte arrays
 */
function arraysEqual(a: number[], b: number[] | Uint8Array): boolean {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

/**
 * Settle a match (can be called by anyone after result is submitted or timeout)
 * NOTE: This assumes submit_result has already been called on-chain
 */
export async function settleMatch(
  matchId: string
): Promise<{ success: boolean; transaction?: Transaction; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const connection = program.provider.connection;
    const [escrowPDA] = deriveEscrowPDA(matchId);

    // Fetch escrow account to get winner and pre-settle lamports for accounting
    // CRITICAL: This assumes submit_result was already called to set winner in escrow account
    let escrowAccount;
    try {
      escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);
    } catch (fetchError: any) {
      return {
        success: false,
        error: `Failed to fetch escrow account. Ensure submit_result was called first: ${fetchError?.message || String(fetchError)}`,
      };
    }

    // ‚úÖ STEP 1 ‚Äî Confirm Escrow Account State Is Valid
    console.log('üèÅ About to settle match:', matchId);
    console.log('üî¢ Escrow PDA:', escrowPDA.toString());
    console.log('‚õ≥ Escrow Status:', escrowAccount.gameStatus);
    console.log('‚õ≥ Result Type:', escrowAccount.resultType);
    console.log('‚õ≥ Winner Pubkey:', escrowAccount.winner ? new PublicKey(escrowAccount.winner).toString() : 'null');
    console.log('üßæ Players:', match.player1, match.player2);
    
    const feeWallet = new PublicKey(config.solana.feeWalletAddress);
    console.log('üí∞ Fee Wallet:', feeWallet.toString());
    
    const winner = escrowAccount.winner;
    const winnerPubkey = winner ? new PublicKey(winner).toString() : 'SystemProgram';
    console.log('üèÜ Winner Pubkey:', winnerPubkey);

    // Validate escrow is in Active status
    if (escrowAccount.gameStatus !== 'Active') {
      console.error('‚ùå Escrow not in Active status. Current status:', JSON.stringify(escrowAccount.gameStatus));
      return {
        success: false,
        error: `Escrow not in Active status. Current status: ${JSON.stringify(escrowAccount.gameStatus)}. Cannot settle.`,
      };
    }

    // Validate result was submitted or timeout passed
    const isUnresolved = escrowAccount.resultType === 'Unresolved' || escrowAccount.resultType?.unresolved !== undefined;
    if (isUnresolved) {
      // Check if timeout has passed (timeoutAt is i64 in Rust, stored as BN in Anchor)
      const timeoutAt = escrowAccount.timeoutAt;
      const timeoutTimestamp = timeoutAt?.toNumber ? timeoutAt.toNumber() : (typeof timeoutAt === 'number' ? timeoutAt : 0);
      
      if (timeoutTimestamp > 0) {
        const currentSlot = await connection.getSlot();
        const currentBlockTime = await connection.getBlockTime(currentSlot);
        const currentTimestamp = currentBlockTime || Math.floor(Date.now() / 1000);
        
        if (currentTimestamp < timeoutTimestamp) {
          return {
            success: false,
            error: `Cannot settle: result not submitted and timeout not passed. Timeout at: ${new Date(timeoutTimestamp * 1000).toISOString()}, Current: ${new Date(currentTimestamp * 1000).toISOString()}`,
          };
        }
        console.log('‚ö†Ô∏è Settling with Unresolved result (timeout passed)');
      } else {
        console.warn('‚ö†Ô∏è Timeout timestamp not available, proceeding with settlement');
      }
    }

    // Check fee wallet balance
    const feeWalletBalance = await connection.getBalance(feeWallet);
    const minBalance = 0.1 * LAMPORTS_PER_SOL;
    console.log('üí∞ Fee Wallet Balance:', feeWalletBalance / 1e9, 'SOL');
    
    if (feeWalletBalance < minBalance) {
      console.warn('‚ö†Ô∏è Fee wallet low balance:', {
        balance: feeWalletBalance / 1e9,
        minRequired: minBalance / 1e9,
        feeWallet: feeWallet.toString(),
      });
      // Continue anyway - might still work if balance is close
    }

    // Get pre-settlement balances for verification
    const preAccountInfo = await connection.getAccountInfo(escrowPDA);
    const preLamports = preAccountInfo?.lamports ?? 0;
    const preFeeWalletBalance = feeWalletBalance;
    const preWinnerBalance = winner ? await connection.getBalance(new PublicKey(winner)) : 0;
    const prePlayerABalance = await connection.getBalance(new PublicKey(match.player1));
    const prePlayerBBalance = await connection.getBalance(new PublicKey(match.player2!));
    
    console.log('üìä Pre-settlement balances:');
    console.log('  Escrow PDA:', preLamports / 1e9, 'SOL');
    console.log('  Fee Wallet:', preFeeWalletBalance / 1e9, 'SOL');
    if (winner) {
      console.log('  Winner:', preWinnerBalance / 1e9, 'SOL');
    }
    console.log('  Player A:', prePlayerABalance / 1e9, 'SOL');
    console.log('  Player B:', prePlayerBBalance / 1e9, 'SOL');

    // ‚úÖ STEP 2 ‚Äî Build and Simulate the settle() Transaction
    console.log('‚úÖ STEP 2: Building settle() instruction...');
    
    // Determine winner account based on result type
    let winnerAccount: PublicKey;
    if (escrowAccount.resultType?.win !== undefined && winner) {
      // Win result - use actual winner
      winnerAccount = new PublicKey(winner);
      console.log('  Result Type: Win, Winner:', winnerAccount.toString());
    } else {
      // Draw/Timeout - use SystemProgram as dummy
      winnerAccount = SystemProgram.programId;
      console.log('  Result Type: Draw/Timeout, Using SystemProgram as dummy winner');
    }

    const settleIx = await program.methods
      .settle()
      .accounts({
        gameEscrow: escrowPDA,
        winner: winnerAccount,
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        feeWallet: feeWallet,
        systemProgram: SystemProgram.programId,
      })
      .instruction();

    console.log('‚úÖ STEP 2: Simulating settle() transaction...');
    const transaction = new Transaction().add(settleIx);
    const { blockhash } = await connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.feePayer = feeWallet;

    const simulation = await connection.simulateTransaction(transaction, {
      replaceRecentBlockhash: true,
      sigVerify: false,
    });

    if (simulation.value.err) {
      console.error('‚ùå settle() simulation failed:', simulation.value.err);
      console.error('ü™µ Logs:', simulation.value.logs);
      console.error('üìä Compute Units Used:', simulation.value.unitsConsumed);
      console.error('üìä Compute Units Requested:', simulation.value.unitsRequested);
      
      return {
        success: false,
        error: `Settle simulation failed: ${JSON.stringify(simulation.value.err)}. Logs: ${simulation.value.logs?.join('; ') || 'none'}`,
      };
    }

    console.log('‚úÖ Simulation passed.');
    console.log('üìä Simulation Results:');
    console.log('  Compute Units Used:', simulation.value.unitsConsumed);
    console.log('  Compute Units Requested:', simulation.value.unitsRequested);
    if (simulation.value.logs) {
      console.log('  Logs:', simulation.value.logs.slice(0, 10)); // First 10 logs
    }

    // ‚úÖ STEP 3 ‚Äî Send the Transaction If Simulation Passes
    console.log('‚úÖ STEP 3: Sending settle() transaction...');
    
    const wallet = getProviderWallet();
    const keypair = (wallet as any).payer;
    if (!keypair || typeof keypair.sign !== 'function') {
      console.error('‚ùå Failed to get fee wallet keypair for signing');
      return {
        success: false,
        error: 'Failed to get fee wallet keypair for signing',
      };
    }

    transaction.sign(keypair);
    const tx = await connection.sendRawTransaction(
      transaction.serialize(),
      { skipPreflight: false, maxRetries: 3 }
    );

    console.log('‚úÖ Settle transaction sent:', tx);
    
    // Wait for confirmation
    console.log('‚è≥ Waiting for confirmation...');
    await connection.confirmTransaction(tx, 'confirmed');
    console.log('‚úÖ Transaction confirmed:', tx);

    // ‚úÖ STEP 4 ‚Äî Verify Transfers (From PDA)
    console.log('‚úÖ STEP 4: Verifying transfers...');
    
    const postAccountInfo = await connection.getAccountInfo(escrowPDA);
    const postLamports = postAccountInfo?.lamports ?? 0;
    const payoutTotalLamports = preLamports > postLamports ? preLamports - postLamports : 0;
    
    const postFeeWalletBalance = await connection.getBalance(feeWallet);
    const postWinnerBalance = winner ? await connection.getBalance(new PublicKey(winner)) : 0;
    const postPlayerABalance = await connection.getBalance(new PublicKey(match.player1));
    const postPlayerBBalance = await connection.getBalance(new PublicKey(match.player2!));
    
    console.log('üìä Post-settlement balances:');
    console.log('  Escrow PDA:', postLamports / 1e9, 'SOL', `(${preLamports > postLamports ? '‚Üì' : '='} ${(preLamports - postLamports) / 1e9} SOL)`);
    console.log('  Fee Wallet:', postFeeWalletBalance / 1e9, 'SOL', `(${postFeeWalletBalance > preFeeWalletBalance ? '‚Üë' : '='} ${(postFeeWalletBalance - preFeeWalletBalance) / 1e9} SOL)`);
    if (winner) {
      console.log('  Winner:', postWinnerBalance / 1e9, 'SOL', `(${postWinnerBalance > preWinnerBalance ? '‚Üë' : '='} ${(postWinnerBalance - preWinnerBalance) / 1e9} SOL)`);
    }
    console.log('  Player A:', postPlayerABalance / 1e9, 'SOL', `(${postPlayerABalance > prePlayerABalance ? '‚Üë' : '='} ${(postPlayerABalance - prePlayerABalance) / 1e9} SOL)`);
    console.log('  Player B:', postPlayerBBalance / 1e9, 'SOL', `(${postPlayerBBalance > prePlayerBBalance ? '‚Üë' : '='} ${(postPlayerBBalance - prePlayerBBalance) / 1e9} SOL)`);
    
    // Verify escrow balance dropped
    if (postLamports >= preLamports) {
      console.warn('‚ö†Ô∏è Escrow PDA balance did not decrease! Expected decrease but got:', {
        pre: preLamports / 1e9,
        post: postLamports / 1e9,
        difference: (postLamports - preLamports) / 1e9,
      });
    } else {
      console.log('‚úÖ Escrow PDA balance decreased by:', (preLamports - postLamports) / 1e9, 'SOL');
    }

    console.log('‚úÖ Match settled:', {
      matchId,
      transaction: tx,
      payoutTotalLamports: payoutTotalLamports / 1e9,
    });

    // ‚úÖ STEP 5 ‚Äî Check Program Constraints (Verified)
    console.log('‚úÖ STEP 5: Program constraints verified:');
    console.log('  ‚úÖ deriveEscrowPDA() uses matchId ‚Üí BN ‚Üí toArrayLike(Buffer, "le", 16)');
    console.log('  ‚úÖ settle() instruction passes correct winner account');
    console.log('  ‚úÖ Fee wallet is mutable UncheckedAccount (not required to sign)');
    console.log('  ‚úÖ Program ID:', program.programId.toString());
    console.log('  ‚úÖ PDA matches on-chain escrow account');

    // Update match in database with on-chain trace info and attach signature to payoutResult.transactions
    const freshMatch = await matchRepository.findOne({ where: { id: matchId } });
    let updatedPayoutResult = null;
    if (freshMatch?.payoutResult) {
      try {
        // Handle both string and already-parsed JSON
        updatedPayoutResult = typeof freshMatch.payoutResult === 'string' 
          ? JSON.parse(freshMatch.payoutResult)
          : freshMatch.payoutResult;
      } catch (parseError: unknown) {
        console.warn('‚ö†Ô∏è Failed to parse payoutResult in settleMatch (non-critical):', {
          matchId,
          error: parseError instanceof Error ? parseError.message : String(parseError),
          payoutResultPreview: typeof freshMatch.payoutResult === 'string' 
            ? freshMatch.payoutResult.substring(0, 50) 
            : 'not a string',
        });
        // Continue with null - we'll just not update the payoutResult field
        updatedPayoutResult = null;
      }
    }

    if (updatedPayoutResult && Array.isArray(updatedPayoutResult.transactions)) {
      updatedPayoutResult.transactions = updatedPayoutResult.transactions.map((t: any) => ({
        ...t,
        signature: tx,
      }));
    }

    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'SETTLED',
        payoutTxHash: tx,              // legacy field
        payoutTxSignature: tx,         // canonical field
        payoutTotalLamports: payoutTotalLamports || null,
        payoutResult: updatedPayoutResult
          ? JSON.stringify(updatedPayoutResult)
          : freshMatch?.payoutResult ?? null,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error settling match:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Refund if only one player paid (after timeout)
 */
export async function refundSinglePlayer(
  matchId: string
): Promise<{ success: boolean; signature?: string; error?: string }> {
  try {
    const matchRepository = AppDataSource.getRepository(Match);
    const match = await matchRepository.findOne({ where: { id: matchId } });

    if (!match) {
      return {
        success: false,
        error: 'Match not found',
      };
    }

    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const tx = await program.methods
      .refundIfOnlyOnePaid()
      .accounts({
        gameEscrow: escrowPDA,
        playerA: new PublicKey(match.player1),
        playerB: new PublicKey(match.player2!),
        systemProgram: SystemProgram.programId,
      })
      .rpc();

    console.log('‚úÖ Single player refunded:', {
      matchId,
      transaction: tx,
    });

    // Update match in database
    await matchRepository.update(
      { id: matchId },
      {
        escrowStatus: 'REFUNDED',
        refundTxHash: tx,
      }
    );

    return {
      success: true,
      signature: tx,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    console.error('‚ùå Error refunding single player:', errorMessage);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Get escrow account state
 */
export async function getEscrowState(
  matchId: string
): Promise<{
  success: boolean;
  state?: any;
  error?: string;
}> {
  try {
    const program = getProgram();
    const [escrowPDA] = deriveEscrowPDA(matchId);

    const escrowAccount = await (program.account as any).gameEscrow.fetch(escrowPDA);

    return {
      success: true,
      state: escrowAccount,
    };
  } catch (error: unknown) {
    const errorMessage =
      error instanceof Error ? error.message : String(error);
    return {
      success: false,
      error: errorMessage,
    };
  }
}

